<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>The ZipArchive Library: ZipArchive.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff" leftmargin="32" marginwidth="32" topmargin="32" marginheight="32">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>ZipArchive.h</h1><a href="ZipArchive_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//&lt;!-- Code:License --&gt;</span>
<a name="l00002"></a>00002 <span class="comment">// Check the site http://www.artpol-software.com for the updated version of the library.</span>
<a name="l00003"></a>00003 <span class="comment">//   </span>
<a name="l00004"></a>00004 <span class="comment">// The following information files are distributed along with this library:</span>
<a name="l00005"></a>00005 <span class="comment">//  License.txt  - licensing information</span>
<a name="l00006"></a>00006 <span class="comment">//  Appnote.txt  - details on the zip format</span>
<a name="l00007"></a>00007 <span class="comment">//       ( also available at ftp://ftp.pkware.com/appnote.zip)</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009  
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 
<a name="l00018"></a>00018 <span class="preprocessor">#if !defined(ZIPARCHIVE_ZIPARCHIVE_DOT_H)</span>
<a name="l00019"></a><a class="code" href="ZipArchive_8h.html#87bf74853447e422525b16c7f8cae046">00019</a> <span class="preprocessor"></span><span class="preprocessor">#define ZIPARCHIVE_ZIPARCHIVE_DOT_H</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#if (_MSC_VER &gt; 1000) &amp;&amp; (defined ZIP_HAS_DLL)</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning (push)</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning( disable : 4251 ) // needs to have dll-interface to be used by clients of class</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning( disable : 4275 ) // non dll-interface class used as base for dll-interface</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "zlib/zlib.h"</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include "<a class="code" href="ZipException_8h.html">ZipException.h</a>"</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include "<a class="code" href="ZipAutoBuffer_8h.html">ZipAutoBuffer.h</a>"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include "<a class="code" href="ZipCentralDir_8h.html">ZipCentralDir.h</a>"</span> 
<a name="l00032"></a>00032 <span class="preprocessor">#include "<a class="code" href="ZipStorage_8h.html">ZipStorage.h</a>"</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include "<a class="code" href="ZipPathComponent_8h.html">ZipPathComponent.h</a>"</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include "ZipString.h"</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include "ZipExport.h"</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include "<a class="code" href="ZipCryptograph_8h.html">ZipCryptograph.h</a>"</span>
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="ZipArchive_8h.html#4198ee360d2d7075e959921d1d80e76d">00038</a> <span class="preprocessor">#define ZIP_AUTODETECT_VOLUME_SIZE ZIP_U32_U64(-1)</span>
<a name="l00039"></a><a class="code" href="ZipArchive_8h.html#75a7e88d05831352d7e455758a6c64d3">00039</a> <span class="preprocessor"></span><span class="preprocessor">#define ZIP_WINZIP_AES_COMPRESSION_METHOD 99</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00048"></a><a class="code" href="structCZipAddNewFileInfo.html">00048</a> <span class="keyword">struct </span>ZIP_API <a class="code" href="structCZipAddNewFileInfo.html">CZipAddNewFileInfo</a>
<a name="l00049"></a>00049 {
<a name="l00059"></a><a class="code" href="structCZipAddNewFileInfo.html#cddea5d82dbbe1696714dd2783aeef1b">00059</a>  <a class="code" href="structCZipAddNewFileInfo.html">CZipAddNewFileInfo</a>(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>)
<a name="l00060"></a>00060   : m_szFilePath(lpszFilePath),m_bFullPath(bFullPath)
<a name="l00061"></a>00061  {
<a name="l00062"></a>00062   m_pFile = NULL;
<a name="l00063"></a>00063   Defaults();
<a name="l00064"></a>00064  }
<a name="l00065"></a>00065 
<a name="l00075"></a><a class="code" href="structCZipAddNewFileInfo.html#9627213821839603a929eaa9c6ca7d59">00075</a>  <a class="code" href="structCZipAddNewFileInfo.html">CZipAddNewFileInfo</a>(LPCTSTR lpszFilePath, LPCTSTR lpszFileNameInZip)
<a name="l00076"></a>00076   : m_szFilePath(lpszFilePath), m_szFileNameInZip(lpszFileNameInZip)
<a name="l00077"></a>00077  {
<a name="l00078"></a>00078   m_pFile = NULL;
<a name="l00079"></a>00079   Defaults();
<a name="l00080"></a>00080  }
<a name="l00081"></a>00081 
<a name="l00091"></a><a class="code" href="structCZipAddNewFileInfo.html#f8faba175a235a9756953434dd018ad6">00091</a>  <a class="code" href="structCZipAddNewFileInfo.html">CZipAddNewFileInfo</a>(CZipAbstractFile* pFile, LPCTSTR lpszFileNameInZip)
<a name="l00092"></a>00092   : m_pFile(pFile), m_szFileNameInZip(lpszFileNameInZip)
<a name="l00093"></a>00093  {
<a name="l00094"></a>00094   Defaults();
<a name="l00095"></a>00095  }
<a name="l00096"></a>00096 
<a name="l00102"></a><a class="code" href="structCZipAddNewFileInfo.html#54e49f36a7dc9e1e6f16651e8e5c44e2">00102</a>  CZipString m_szFilePath;  
<a name="l00103"></a>00103 
<a name="l00109"></a><a class="code" href="structCZipAddNewFileInfo.html#85d4df19e154636eedd209397c00574d">00109</a>  CZipString m_szFileNameInZip;
<a name="l00110"></a>00110  
<a name="l00123"></a><a class="code" href="structCZipAddNewFileInfo.html#5deb0d0300f95c700473170ec9902756">00123</a>  <span class="keywordtype">bool</span> m_bFullPath;
<a name="l00124"></a>00124 
<a name="l00129"></a><a class="code" href="structCZipAddNewFileInfo.html#9a636d5fec970c50215b0a4537539070">00129</a>  <span class="keywordtype">int</span> m_iComprLevel;    
<a name="l00130"></a>00130 
<a name="l00135"></a><a class="code" href="structCZipAddNewFileInfo.html#a512569a7c8c79e2b5dcc450ab355946">00135</a>  <span class="keywordtype">int</span> m_iSmartLevel;
<a name="l00136"></a>00136 
<a name="l00154"></a><a class="code" href="structCZipAddNewFileInfo.html#bb892e3bf51186fd7697f94b70af0b16">00154</a>  ZIP_U16_U64 m_uReplaceIndex;  
<a name="l00155"></a>00155 
<a name="l00159"></a><a class="code" href="structCZipAddNewFileInfo.html#90629c2d180ad6c95369e09dda252a5d">00159</a>  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m_nBufSize;  
<a name="l00160"></a>00160 
<a name="l00171"></a><a class="code" href="structCZipAddNewFileInfo.html#cd656262c3f3f2c454c80b3f28f16d3f">00171</a>  CZipAbstractFile* m_pFile;
<a name="l00172"></a>00172 
<a name="l00177"></a>00177  <span class="keywordtype">void</span> Defaults();
<a name="l00178"></a>00178 };
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 
<a name="l00185"></a><a class="code" href="classCZipArchive.html">00185</a> <span class="keyword">class </span>ZIP_API CZipArchive  
<a name="l00186"></a>00186 { 
<a name="l00187"></a>00187 <span class="keyword">public</span>:
<a name="l00188"></a>00188 
<a name="l00193"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html">00193</a>  <span class="keyword">struct </span>ZIP_API CZipInternalInfo  
<a name="l00194"></a>00194  { 
<a name="l00195"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#27409f73cd7c3430831be8a92b2292cf">00195</a>   CZipInternalInfo()
<a name="l00196"></a>00196   {
<a name="l00197"></a>00197    m_iBufferSize = 65536;
<a name="l00198"></a>00198    m_uUncomprLeft = 0;
<a name="l00199"></a>00199    m_uComprLeft  = 0;
<a name="l00200"></a>00200    m_uCrc32 = 0;
<a name="l00201"></a>00201   }
<a name="l00202"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#b44343b10b526d18e59ada4f23298811">00202</a>   <span class="keyword">virtual</span> ~CZipInternalInfo(){}
<a name="l00203"></a>00203 
<a name="l00207"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#a5b30aac4aa2c17d28bd4a26c49add7d">00207</a>   <span class="keywordtype">void</span> Init()
<a name="l00208"></a>00208   {
<a name="l00209"></a>00209    m_pBuffer.Allocate(m_iBufferSize);
<a name="l00210"></a>00210   }
<a name="l00211"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#f343f1db722dcb2f140cd1afcd576f1a">00211</a>   <span class="keywordtype">void</span> ReleaseBuf()
<a name="l00212"></a>00212   {
<a name="l00213"></a>00213    m_pBuffer.Release();
<a name="l00214"></a>00214   }
<a name="l00215"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#51019d2a4e1af3f8b7a8387ac4e4f4e0">00215</a>   z_stream m_stream;   
<a name="l00216"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#10a0f99f6682b95229ad31b95ee94b38">00216</a>   ZIP_U32_U64 m_uUncomprLeft; 
<a name="l00217"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#ab9593e27c407d80097f326fdfbbe37a">00217</a>   ZIP_U32_U64 m_uComprLeft; 
<a name="l00218"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#9f615678cc99d8edf95397e7fc17a92d">00218</a>   DWORD m_uCrc32;    
<a name="l00219"></a>00219 
<a name="l00228"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#64b8343461a67e0067968bd49d5e1a8b">00228</a>   DWORD m_iBufferSize;
<a name="l00229"></a>00229 
<a name="l00233"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#097c0919cd025816f8941212c281c1c2">00233</a>   <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> m_pBuffer;
<a name="l00234"></a>00234  };
<a name="l00235"></a>00235 
<a name="l00236"></a>00236  CZipArchive();
<a name="l00237"></a>00237  <span class="keyword">virtual</span> ~CZipArchive();
<a name="l00238"></a>00238  
<a name="l00255"></a>00255  <span class="keywordtype">bool</span> SetPassword(LPCTSTR lpszPassword = NULL); 
<a name="l00256"></a>00256 
<a name="l00264"></a>00264  CZipString GetPassword()<span class="keyword">const </span>;
<a name="l00265"></a>00265 
<a name="l00289"></a>00289  <span class="keywordtype">bool</span> SetEncryptionMethod(<span class="keywordtype">int</span> iEncryptionMethod = <a class="code" href="classCZipCryptograph.html#b3e0a46c0680f616ccf7a163f4f403323acf6a872aa7b3c932d9e8179ecbeb6a">CZipCryptograph::encStandard</a>);
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 
<a name="l00300"></a><a class="code" href="classCZipArchive.html#31b4d1f238c27c15e971aa3a949c39c2">00300</a>  <span class="keywordtype">int</span> GetEncryptionMethod()<span class="keyword"> const</span>
<a name="l00301"></a>00301 <span class="keyword"> </span>{
<a name="l00302"></a>00302   <span class="keywordflow">return</span> m_iEncryptionMethod;
<a name="l00303"></a>00303  }
<a name="l00304"></a>00304 
<a name="l00323"></a>00323  <span class="keywordtype">void</span> SetAdvanced(<span class="keywordtype">int</span> iWriteBuffer = 65536, <span class="keywordtype">int</span> iGeneralBuffer = 65536, <span class="keywordtype">int</span> iSearchBuffer = 32768);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325  
<a name="l00338"></a><a class="code" href="classCZipArchive.html#959036df52c025afe050e22299d1c533">00338</a>  <span class="keywordtype">void</span> GetAdvanced(<span class="keywordtype">int</span>* piWriteBuffer = NULL, <span class="keywordtype">int</span>* piGeneralBuffer = NULL, <span class="keywordtype">int</span>* piSearchBuffer= NULL)
<a name="l00339"></a>00339  {
<a name="l00340"></a>00340   <span class="keywordflow">if</span> (piWriteBuffer)
<a name="l00341"></a>00341    *piWriteBuffer =  m_storage.m_iWriteBufferSize;
<a name="l00342"></a>00342   <span class="keywordflow">if</span> (piGeneralBuffer)
<a name="l00343"></a>00343    *piGeneralBuffer = m_info.m_iBufferSize;
<a name="l00344"></a>00344   <span class="keywordflow">if</span> (piSearchBuffer)
<a name="l00345"></a>00345    *piSearchBuffer = m_storage.m_iLocateBufferSize;
<a name="l00346"></a>00346  }
<a name="l00347"></a>00347 
<a name="l00358"></a><a class="code" href="classCZipArchive.html#07cdf46e463d58a346e8446f7e7b8730">00358</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#07cdf46e463d58a346e8446f7e7b8730">CallbackType</a>
<a name="l00359"></a>00359  {
<a name="l00365"></a>00365   cbNothing = 0x0000,
<a name="l00366"></a>00366 
<a name="l00372"></a>00372   cbAdd  = 0x0001,
<a name="l00373"></a>00373 
<a name="l00381"></a>00381   cbAddTmp = 0x0002,
<a name="l00382"></a>00382 
<a name="l00391"></a>00391   cbAddStore = 0x0004, 
<a name="l00392"></a>00392 
<a name="l00398"></a>00398   cbExtract = 0x0008,
<a name="l00399"></a>00399 
<a name="l00407"></a>00407   cbDeleteCnt = 0x0010,
<a name="l00408"></a>00408 
<a name="l00415"></a>00415   cbDelete = 0x0020,
<a name="l00416"></a>00416 
<a name="l00422"></a>00422   cbTest  = 0x0040,
<a name="l00423"></a>00423 
<a name="l00431"></a>00431   cbSave  = 0x0080,
<a name="l00432"></a>00432 
<a name="l00438"></a>00438   cbGet  = 0x0100,
<a name="l00439"></a>00439 
<a name="l00446"></a>00446   cbRename = 0x0200,
<a name="l00447"></a>00447 
<a name="l00454"></a>00454   cbReplace = 0x0400,
<a name="l00455"></a>00455 
<a name="l00461"></a>00461   cbNextValue = 0x0800,
<a name="l00462"></a>00462   
<a name="l00469"></a>00469   cbSubActions= cbAddTmp | cbAddStore | cbDeleteCnt | cbReplace,
<a name="l00470"></a>00470 
<a name="l00476"></a>00476   cbActions = cbAdd | cbExtract | cbDelete | cbTest | cbSave | cbGet | cbRename,
<a name="l00477"></a>00477 
<a name="l00483"></a>00483   cbAll  = cbActions | cbSubActions
<a name="l00484"></a>00484  };
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00507"></a>00507  <span class="keywordtype">void</span> SetCallback(<a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback = NULL, <span class="keywordtype">int</span> iWhich = cbAll);
<a name="l00508"></a>00508 
<a name="l00520"></a><a class="code" href="classCZipArchive.html#78c8325f8a38b9e4c527d3d35dfd763e">00520</a>  <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* GetCallback(<a class="code" href="classCZipArchive.html#07cdf46e463d58a346e8446f7e7b8730">CallbackType</a> iWhich)
<a name="l00521"></a>00521  {
<a name="l00522"></a>00522   <span class="keywordflow">return</span> m_callbacks.Get(iWhich);
<a name="l00523"></a>00523  }
<a name="l00524"></a>00524 
<a name="l00539"></a><a class="code" href="classCZipArchive.html#a3dbddb407a5bf8c2100183534654960">00539</a>  <span class="keywordtype">void</span> SetSpanCallback(<a class="code" href="structCZipSpanCallback.html">CZipSpanCallback</a>* pCallback = NULL){m_storage.m_pChangeDiskFunc = pCallback;}
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 
<a name="l00542"></a>00542  
<a name="l00547"></a><a class="code" href="classCZipArchive.html#5d80f4df2aa34edda55d5fb98cffafdb">00547</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#5d80f4df2aa34edda55d5fb98cffafdb">OpenMode</a>
<a name="l00548"></a>00548  {
<a name="l00549"></a>00549   zipOpen,   
<a name="l00550"></a>00550   zipOpenReadOnly, 
<a name="l00551"></a>00551   zipCreate,   
<a name="l00552"></a><a class="code" href="classCZipArchive.html#5d80f4df2aa34edda55d5fb98cffafdb1b5851f780ea1d558bf60503d5795c54">00552</a>   zipCreateSegm  
<a name="l00553"></a>00553  };
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00595"></a>00595  <span class="keywordtype">void</span> Open(LPCTSTR szPathName, <span class="keywordtype">int</span> iMode = zipOpen, ZIP_U32_U64 uVolumeSize = 0);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 
<a name="l00616"></a>00616  <span class="keywordtype">void</span> Open(CZipAbstractFile&amp; af, <span class="keywordtype">int</span> iMode = zipOpen);
<a name="l00617"></a>00617 
<a name="l00639"></a>00639  <span class="keywordtype">void</span> SetRootPath(LPCTSTR szPath = NULL);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 
<a name="l00651"></a><a class="code" href="classCZipArchive.html#e3be82d145694697f3c2d62b3040fba3">00651</a>  CZipString GetRootPath()<span class="keyword">const </span>
<a name="l00652"></a>00652 <span class="keyword"> </span>{
<a name="l00653"></a>00653   <span class="keywordflow">return</span> m_szRootPath;
<a name="l00654"></a>00654  }
<a name="l00655"></a>00655 
<a name="l00663"></a><a class="code" href="classCZipArchive.html#578cdd94533678eb97c099102eaf669f">00663</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#578cdd94533678eb97c099102eaf669f">Smartness</a>
<a name="l00664"></a>00664  {
<a name="l00665"></a>00665   zipsmLazy   = 0x0000,  
<a name="l00666"></a>00666   zipsmCPassDir  = 0x0001,  
<a name="l00667"></a>00667   zipsmCPFile0  = 0x0002,  
<a name="l00668"></a>00668 
<a name="l00672"></a>00672   zipsmNotCompSmall = 0x0004,
<a name="l00673"></a>00673 
<a name="l00684"></a>00684   zipsmCheckForEff = 0x0008,
<a name="l00685"></a>00685 
<a name="l00691"></a>00691   zipsmMemoryFlag  = 0x0010,
<a name="l00692"></a>00692 
<a name="l00698"></a>00698   zipsmCheckForEffInMem = zipsmMemoryFlag | zipsmCheckForEff,
<a name="l00699"></a>00699   zipsmSmartPass = zipsmCPassDir | zipsmCPFile0,   
<a name="l00700"></a>00700   zipsmSmartAdd = zipsmNotCompSmall | zipsmCheckForEff, 
<a name="l00701"></a>00701   zipsmSafeSmart = zipsmSmartPass | zipsmNotCompSmall,    
<a name="l00702"></a>00702   zipsmSmartest = zipsmSmartPass | zipsmSmartAdd,   
<a name="l00703"></a><a class="code" href="classCZipArchive.html#578cdd94533678eb97c099102eaf669f5404e507c5ab3caae3eac39bf8c61005">00703</a>   zipsmInternal01  = 0xf000   
<a name="l00704"></a>00704  };
<a name="l00705"></a>00705 
<a name="l00706"></a>00706  
<a name="l00735"></a>00735  <span class="keywordtype">bool</span> AddNewFile(<a class="code" href="structCZipAddNewFileInfo.html">CZipAddNewFileInfo</a>&amp; info);
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 
<a name="l00744"></a>00744  <span class="keywordtype">bool</span> AddNewFile(LPCTSTR lpszFilePath, <span class="keywordtype">int</span> iComprLevel = -1, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>,
<a name="l00745"></a>00745   <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 
<a name="l00753"></a>00753  <span class="keywordtype">bool</span> AddNewFile(LPCTSTR lpszFilePath,
<a name="l00754"></a>00754         LPCTSTR lpszFileNameInZip,
<a name="l00755"></a>00755                              <span class="keywordtype">int</span> iComprLevel = -1,                             
<a name="l00756"></a>00756         <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart,
<a name="l00757"></a>00757                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
<a name="l00758"></a>00758 
<a name="l00764"></a>00764  <span class="keywordtype">bool</span> AddNewFile(<a class="code" href="classCZipMemFile.html">CZipMemFile</a>&amp; mf,
<a name="l00765"></a>00765         LPCTSTR lpszFileNameInZip,
<a name="l00766"></a>00766                              <span class="keywordtype">int</span> iComprLevel = -1,                             
<a name="l00767"></a>00767         <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart,
<a name="l00768"></a>00768                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 
<a name="l00837"></a><a class="code" href="classCZipArchive.html#d9827df20cf92f6e2661571215af8a06">00837</a>  <span class="keywordtype">bool</span> OpenNewFile(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>&amp; header, <span class="keywordtype">int</span> iLevel = Z_DEFAULT_COMPRESSION, LPCTSTR lpszFilePath = NULL)
<a name="l00838"></a>00838  {
<a name="l00839"></a>00839   <span class="keywordflow">return</span> OpenNewFile(header, iLevel, lpszFilePath, ZIP_FILE_INDEX_UNSPECIFIED);
<a name="l00840"></a>00840  }
<a name="l00841"></a>00841 
<a name="l00864"></a>00864  <span class="keywordtype">bool</span> WriteNewFile(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, DWORD iSize);
<a name="l00865"></a>00865 
<a name="l00886"></a>00886  <span class="keywordtype">bool</span> CloseNewFile(<span class="keywordtype">bool</span> bAfterException = <span class="keyword">false</span>);
<a name="l00887"></a>00887 
<a name="l00937"></a><a class="code" href="classCZipArchive.html#176dd7ab97241761f68f461265e32b0f">00937</a>  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, ZIP_U16_U64 uIndex, LPCTSTR lpszNewFileName = NULL, ZIP_U16_U64 uReplaceIndex = ZIP_FILE_INDEX_UNSPECIFIED, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>)
<a name="l00938"></a>00938  {
<a name="l00939"></a>00939     
<a name="l00940"></a>00940   m_info.Init();
<a name="l00941"></a>00941   <span class="keywordtype">bool</span> bRet;
<a name="l00942"></a>00942   <span class="keywordflow">try</span>
<a name="l00943"></a>00943   {
<a name="l00944"></a>00944    bRet = GetFromArchive(zip, uIndex, lpszNewFileName, uReplaceIndex, bKeepSystComp, GetCallback(cbGet));
<a name="l00945"></a>00945   }
<a name="l00946"></a>00946   <span class="keywordflow">catch</span>(...)
<a name="l00947"></a>00947   {
<a name="l00948"></a>00948    m_info.ReleaseBuf();
<a name="l00949"></a>00949    <span class="keywordflow">throw</span>;
<a name="l00950"></a>00950   }
<a name="l00951"></a>00951   m_info.ReleaseBuf();
<a name="l00952"></a>00952   <span class="keywordflow">if</span> (bRet &amp;&amp; m_bAutoFlush)
<a name="l00953"></a>00953    Flush();
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="keywordflow">return</span> bRet;
<a name="l00956"></a>00956  }
<a name="l00957"></a>00957 
<a name="l01001"></a>01001  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, CZipIndexesArray &amp;aIndexes, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>);
<a name="l01002"></a>01002  
<a name="l01050"></a><a class="code" href="classCZipArchive.html#089c9e3fa4d74ef21585b0b749b15ab5">01050</a>  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, CZipStringArray &amp;aNames, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>)
<a name="l01051"></a>01051  {
<a name="l01052"></a>01052   CZipIndexesArray indexes;
<a name="l01053"></a>01053   zip.<a class="code" href="classCZipArchive.html#95573d33042d4adc73f36f4b1a7a0b3a">GetIndexes</a>(aNames, indexes);
<a name="l01054"></a>01054   <span class="keywordflow">return</span> GetFromArchive(zip, indexes, bKeepSystComp);
<a name="l01055"></a>01055   
<a name="l01056"></a>01056  }
<a name="l01057"></a>01057 
<a name="l01076"></a>01076  <span class="keywordtype">void</span> GetIndexes(<span class="keyword">const</span> CZipStringArray &amp;aNames, CZipIndexesArray&amp; aIndexes);
<a name="l01077"></a>01077 
<a name="l01131"></a>01131  <span class="keywordtype">bool</span> ExtractFile(ZIP_U16_U64 uIndex, LPCTSTR lpszPath, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>,
<a name="l01132"></a>01132   LPCTSTR lpszNewName = NULL, DWORD nBufSize = 65536);
<a name="l01133"></a>01133 
<a name="l01134"></a>01134  
<a name="l01164"></a>01164  <span class="keywordtype">bool</span> ExtractFile(ZIP_U16_U64 uIndex, <a class="code" href="classCZipMemFile.html">CZipMemFile</a>&amp; mf, <span class="keywordtype">bool</span> bRewind = <span class="keyword">true</span>, DWORD nBufSize = 65536);
<a name="l01165"></a>01165 
<a name="l01188"></a>01188  <span class="keywordtype">bool</span> <a class="code" href="namespaceZipPlatform.html#3c1d17d400f71485ff45bba1a43aa411">OpenFile</a>(ZIP_U16_U64 uIndex);
<a name="l01189"></a>01189 
<a name="l01210"></a>01210  DWORD ReadFile(<span class="keywordtype">void</span> *pBuf, DWORD uSize);
<a name="l01211"></a>01211 
<a name="l01242"></a>01242  <span class="keywordtype">int</span> CloseFile(LPCTSTR lpszFilePath = NULL, <span class="keywordtype">bool</span> bAfterException = <span class="keyword">false</span>);
<a name="l01243"></a>01243 
<a name="l01265"></a>01265  <span class="keywordtype">int</span> CloseFile(CZipFile &amp;file);
<a name="l01266"></a>01266 
<a name="l01290"></a>01290  <span class="keywordtype">bool</span> TestFile(ZIP_U16_U64 uIndex, DWORD uBufSize = 65536);
<a name="l01291"></a>01291 
<a name="l01314"></a>01314  <span class="keywordtype">void</span> DeleteFile(ZIP_U16_U64 uIndex);
<a name="l01315"></a>01315 
<a name="l01339"></a>01339  <span class="keywordtype">void</span> DeleteFiles(CZipIndexesArray&amp; aIndexes);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 
<a name="l01364"></a>01364  <span class="keywordtype">void</span> DeleteFiles(<span class="keyword">const</span> CZipStringArray&amp; aNames);
<a name="l01365"></a>01365 
<a name="l01383"></a>01383  <span class="keywordtype">bool</span> SetGlobalComment(LPCTSTR lpszComment);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 
<a name="l01397"></a>01397  CZipString GetGlobalComment()<span class="keyword">const </span>;
<a name="l01398"></a>01398 
<a name="l01399"></a>01399 
<a name="l01420"></a>01420  <span class="keywordtype">bool</span> SetFileComment(ZIP_U16_U64 uIndex, LPCTSTR lpszComment);
<a name="l01421"></a>01421 
<a name="l01436"></a><a class="code" href="classCZipArchive.html#d4e9947c1332f93dba691fc5316cde8b">01436</a>  CZipString GetFileComment(ZIP_U16_U64 uIndex)<span class="keyword"> const</span>
<a name="l01437"></a>01437 <span class="keyword"> </span>{
<a name="l01438"></a>01438   <span class="keyword">const</span> <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* info = GetFileInfo(uIndex);
<a name="l01439"></a>01439   <span class="keywordflow">return</span> info == NULL ? _T(<span class="stringliteral">""</span>) : info-&gt;<a class="code" href="classCZipFileHeader.html#e161d9508adf3b75d954e29e90d365e1">GetComment</a>();
<a name="l01440"></a>01440  }
<a name="l01441"></a>01441 
<a name="l01450"></a>01450  CZipString GetArchivePath()<span class="keyword">const</span>;
<a name="l01451"></a>01451 
<a name="l01465"></a>01465  ZIP_U16_U32 GetCurrentDisk()<span class="keyword">const </span>;
<a name="l01466"></a>01466 
<a name="l01481"></a><a class="code" href="classCZipArchive.html#57b5e58cf7278484892cf6fa9fbaa9b5">01481</a>  <span class="keywordtype">int</span> GetSegmMode()<span class="keyword">const </span>
<a name="l01482"></a>01482 <span class="keyword"> </span>{
<a name="l01483"></a>01483   <span class="keywordflow">return</span> m_storage.m_iSegmMode * m_storage.IsSegmented();
<a name="l01484"></a>01484  }
<a name="l01485"></a>01485 
<a name="l01489"></a><a class="code" href="classCZipArchive.html#f0a22d585f747e1f506491a59fef0445">01489</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#f0a22d585f747e1f506491a59fef0445">FFCaseSens</a>
<a name="l01490"></a>01490  {
<a name="l01498"></a>01498   ffDefault,
<a name="l01499"></a>01499 
<a name="l01507"></a>01507   ffCaseSens,
<a name="l01508"></a>01508 
<a name="l01516"></a>01516   ffNoCaseSens
<a name="l01517"></a>01517  };
<a name="l01518"></a>01518 
<a name="l01548"></a>01548  ZIP_U16_U64 FindFile(LPCTSTR lpszFileName, <span class="keywordtype">int</span> iCaseSensitive = ffDefault, <span class="keywordtype">bool</span> bFileNameOnly = <span class="keyword">false</span>);
<a name="l01549"></a>01549 
<a name="l01575"></a>01575  <span class="keywordtype">bool</span> GetFileInfo(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>&amp; fhInfo, ZIP_U16_U64 uIndex) <span class="keyword">const</span>;
<a name="l01576"></a>01576 
<a name="l01601"></a>01601  <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* GetFileInfo(ZIP_U16_U64 uIndex);
<a name="l01602"></a>01602 
<a name="l01627"></a>01627  <span class="keyword">const</span> <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* GetFileInfo(ZIP_U16_U64 uIndex) <span class="keyword">const</span>;
<a name="l01628"></a>01628 
<a name="l01653"></a><a class="code" href="classCZipArchive.html#b6dc50466cdea17b61d8af0f83519d46">01653</a>  <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* operator[](ZIP_U16_U64 uIndex)
<a name="l01654"></a>01654  {
<a name="l01655"></a>01655   <span class="keywordflow">return</span> GetFileInfo(uIndex);
<a name="l01656"></a>01656  }
<a name="l01657"></a>01657 
<a name="l01681"></a><a class="code" href="classCZipArchive.html#2764bac42dc5678e6d6cad4632a88be1">01681</a>  <span class="keyword">const</span> <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* operator[](ZIP_U16_U64 uIndex)<span class="keyword"> const</span>
<a name="l01682"></a>01682 <span class="keyword"> </span>{
<a name="l01683"></a>01683   <span class="keywordflow">return</span> GetFileInfo(uIndex);
<a name="l01684"></a>01684  }
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 
<a name="l01699"></a><a class="code" href="classCZipArchive.html#daec12f7aa2462e27a2d8bcafdc3d58f">01699</a>  ZIP_U16_U64 GetCount(<span class="keywordtype">bool</span> bOnlyFiles = <span class="keyword">false</span>)<span class="keyword">const </span>
<a name="l01700"></a>01700 <span class="keyword"> </span>{
<a name="l01701"></a>01701   ZIP_U16_U64 iTotalCount = (ZIP_U16_U64) m_centralDir.m_headers.GetSize();
<a name="l01702"></a>01702   <span class="keywordflow">if</span> (bOnlyFiles)
<a name="l01703"></a>01703   {
<a name="l01704"></a>01704    ZIP_U16_U64 iCount = 0;
<a name="l01705"></a>01705    <span class="keywordflow">for</span> (ZIP_U16_U64 i = 0; i &lt; iTotalCount; i++)
<a name="l01706"></a>01706     <span class="keywordflow">if</span> (!m_centralDir.m_headers[i]-&gt;IsDirectory())
<a name="l01707"></a>01707      iCount++;
<a name="l01708"></a>01708    <span class="keywordflow">return</span> iCount;
<a name="l01709"></a>01709   }
<a name="l01710"></a>01710   <span class="keywordflow">else</span>
<a name="l01711"></a>01711    <span class="keywordflow">return</span> iTotalCount;
<a name="l01712"></a>01712  }
<a name="l01723"></a><a class="code" href="classCZipArchive.html#7519cb67cca7ea5130f614987dfb53ae">01723</a>  ZIP_U32_U64 GetOccupiedSpace()<span class="keyword"> const</span>
<a name="l01724"></a>01724 <span class="keyword"> </span>{
<a name="l01725"></a>01725   <span class="keywordflow">if</span> (IsClosed(<span class="keyword">true</span>) || IsClosed(<span class="keyword">false</span>))
<a name="l01726"></a>01726   {
<a name="l01727"></a>01727    ZIPTRACE(<span class="stringliteral">"%s(%i) : ZipArchive or the current volume file is closed.\n"</span>);
<a name="l01728"></a>01728    <span class="keywordflow">return</span> 0;
<a name="l01729"></a>01729   }
<a name="l01730"></a>01730   <span class="keywordflow">return</span> m_storage.GetOccupiedSpace() + m_centralDir.GetSize(<span class="keyword">true</span>);
<a name="l01731"></a>01731  }
<a name="l01732"></a>01732 
<a name="l01736"></a><a class="code" href="classCZipArchive.html#ef1712a894641d675903b34c815de802">01736</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#ef1712a894641d675903b34c815de802">CloseAfterException</a>
<a name="l01737"></a>01737  {
<a name="l01742"></a>01742   afNoException,
<a name="l01743"></a>01743 
<a name="l01750"></a>01750   afAfterException,
<a name="l01751"></a>01751 
<a name="l01758"></a>01758   afWriteDir
<a name="l01759"></a>01759  };
<a name="l01760"></a>01760 
<a name="l01780"></a>01780  <span class="keywordtype">void</span> Close(<span class="keywordtype">int</span> iAfterException = afNoException, <span class="keywordtype">bool</span> bUpdateTimeStamp = <span class="keyword">false</span>);
<a name="l01781"></a>01781 
<a name="l01782"></a>01782 
<a name="l01795"></a><a class="code" href="classCZipArchive.html#60166588e0126c68899860e00676a51f">01795</a>  <span class="keywordtype">bool</span> IsClosed(<span class="keywordtype">bool</span> bArchive = <span class="keyword">true</span>)<span class="keyword">const</span>
<a name="l01796"></a>01796 <span class="keyword"> </span>{
<a name="l01797"></a>01797   <span class="keywordflow">return</span> m_storage.IsClosed(bArchive);
<a name="l01798"></a>01798  }
<a name="l01799"></a>01799 
<a name="l01818"></a>01818  <span class="keywordtype">void</span> Flush();
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 
<a name="l01837"></a>01837  <span class="keywordtype">void</span> SetAutoFlush(<span class="keywordtype">bool</span> bAutoFlush = <span class="keyword">true</span>);
<a name="l01838"></a>01838  
<a name="l01839"></a>01839 
<a name="l01854"></a><a class="code" href="classCZipArchive.html#e455ed2a52254717a623c61afc55d838">01854</a>  <span class="keywordtype">bool</span> GetAutoFlush()<span class="keyword">const </span>{<span class="keywordflow">return</span> m_bAutoFlush;}
<a name="l01855"></a>01855 
<a name="l01880"></a>01880  <span class="keywordtype">bool</span> SetSystemCompatibility(<span class="keywordtype">int</span> iSystemComp);
<a name="l01881"></a>01881 
<a name="l01898"></a><a class="code" href="classCZipArchive.html#51fc17a93c4414130ef440775503fc3e">01898</a>  <span class="keywordtype">int</span> GetSystemCompatibility()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m_iArchiveSystCompatib;}
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 
<a name="l01924"></a>01924  <span class="keywordtype">void</span> SetFileHeaderAttr(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>&amp; header, DWORD uAttr)<span class="keyword">const</span>;
<a name="l01925"></a>01925 
<a name="l01935"></a><a class="code" href="classCZipArchive.html#f2cb18a0c834f64284f6485b01df50a8">01935</a>  <a class="code" href="classCZipStorage.html">CZipStorage</a>* GetStorage(){<span class="keywordflow">return</span> &amp;m_storage;}
<a name="l01936"></a>01936 
<a name="l01937"></a>01937 
<a name="l01946"></a><a class="code" href="classCZipArchive.html#45c363b9d8477533888f9cd748875c7f">01946</a>  <span class="keywordtype">void</span> SetDetectZlibMemoryLeaks(<span class="keywordtype">bool</span> bDetect)
<a name="l01947"></a>01947  {
<a name="l01948"></a>01948   <span class="keywordflow">if</span> (m_iFileOpened != nothing)
<a name="l01949"></a>01949   {
<a name="l01950"></a>01950    ZIPTRACE(<span class="stringliteral">"CZipArchive::SetDetectZlibMemoryLeaks: Set it before opening a file in the archive"</span>);
<a name="l01951"></a>01951    <span class="keywordflow">return</span>;
<a name="l01952"></a>01952   }
<a name="l01953"></a>01953   m_bDetectZlibMemoryLeaks = bDetect;
<a name="l01954"></a>01954   
<a name="l01955"></a>01955  }
<a name="l01956"></a>01956 
<a name="l01974"></a><a class="code" href="classCZipArchive.html#c497dc2ebb4b65be1f5b7d08fe024a29">01974</a>  <span class="keywordtype">void</span> SetStringStoreSettings(<span class="keyword">const</span> CZipStringStoreSettings&amp; settings)
<a name="l01975"></a>01975  {
<a name="l01976"></a>01976   m_centralDir.m_stringSettings = settings;
<a name="l01977"></a>01977  }
<a name="l01978"></a>01978 
<a name="l02002"></a><a class="code" href="classCZipArchive.html#6eadc5f798ca0897e025c2d79771bbd4">02002</a>  <span class="keywordtype">void</span> SetStringStoreSettings(UINT uFileNameCodePage, <span class="keywordtype">bool</span> bStoreNameInExtraData, UINT uCommentCodePage)
<a name="l02003"></a>02003  {
<a name="l02004"></a>02004   m_centralDir.SetStringStoreSettings(uFileNameCodePage, bStoreNameInExtraData, uCommentCodePage);
<a name="l02005"></a>02005  }
<a name="l02006"></a>02006 
<a name="l02028"></a><a class="code" href="classCZipArchive.html#6a2d19de8bb5cc3939bc0d4dce1c1150">02028</a>  <span class="keywordtype">void</span> SetStringStoreSettings(UINT uFileNameCodePage, <span class="keywordtype">bool</span> bStoreNameInExtraData = <span class="keyword">false</span>)
<a name="l02029"></a>02029  {
<a name="l02030"></a>02030   SetStringStoreSettings(uFileNameCodePage, bStoreNameInExtraData,  m_centralDir.m_stringSettings.m_uCommentCodePage);
<a name="l02031"></a>02031  }
<a name="l02032"></a>02032  
<a name="l02047"></a><a class="code" href="classCZipArchive.html#81a15f347bad84ffaeee0c8eff3b98db">02047</a>  <span class="keywordtype">void</span> ResetStringStoreSettings()
<a name="l02048"></a>02048  {
<a name="l02049"></a>02049   SetStringStoreSettings(CZipStringStoreSettings::GetDefaultNameCodePage(m_iArchiveSystCompatib), <span class="keyword">false</span>, CZipStringStoreSettings::GetDefaultCommentCodePage());
<a name="l02050"></a>02050  }
<a name="l02051"></a>02051 
<a name="l02071"></a><a class="code" href="classCZipArchive.html#54f26713f4bc6c808250fe5a0b8b0565">02071</a>  CZipStringStoreSettings&amp; GetStringStoreSettings()
<a name="l02072"></a>02072  {
<a name="l02073"></a>02073   <span class="keywordflow">return</span> m_centralDir.m_stringSettings;
<a name="l02074"></a>02074  }
<a name="l02075"></a>02075 
<a name="l02088"></a>02088  <span class="keywordtype">void</span> EnableFindFast(<span class="keywordtype">bool</span> bEnable = <span class="keyword">true</span>);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090 
<a name="l02109"></a><a class="code" href="classCZipArchive.html#061bf282ada2d1befa2476a476caf48f">02109</a>  ZIP_U16_U64 GetFindFastIndex(ZIP_U16_U64 iFindFastIndex)<span class="keyword"> const</span>
<a name="l02110"></a>02110 <span class="keyword"> </span>{
<a name="l02111"></a>02111   <span class="keywordflow">if</span> (IsClosed())
<a name="l02112"></a>02112   {
<a name="l02113"></a>02113    ZIPTRACE(<span class="stringliteral">"CZipArchive::GetFindFastIndex: ZipArchive not yet opened.\n"</span>);
<a name="l02114"></a>02114    <span class="keywordflow">return</span> ZIP_FILE_INDEX_UNSPECIFIED;
<a name="l02115"></a>02115   }
<a name="l02116"></a>02116   
<a name="l02117"></a>02117   <span class="keywordflow">return</span> m_centralDir.GetFindFastIndex(iFindFastIndex);
<a name="l02118"></a>02118  }
<a name="l02119"></a>02119 
<a name="l02120"></a>02120 
<a name="l02148"></a>02148  <span class="keywordtype">void</span> SetTempPath(LPCTSTR lpszPath = NULL, <span class="keywordtype">bool</span> bForce = <span class="keyword">true</span>);
<a name="l02149"></a>02149 
<a name="l02159"></a><a class="code" href="classCZipArchive.html#2630cb14b005e29eda05cc89eb8b134c">02159</a>  CZipString GetTempPath()<span class="keyword">const </span>
<a name="l02160"></a>02160 <span class="keyword"> </span>{
<a name="l02161"></a>02161   <span class="keywordflow">return</span> m_szTempPath;
<a name="l02162"></a>02162  }
<a name="l02163"></a>02163 
<a name="l02167"></a><a class="code" href="classCZipArchive.html#567d568ba3e724cd41d15db4e7aa724f">02167</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#567d568ba3e724cd41d15db4e7aa724f">Predict</a>
<a name="l02168"></a>02168  {
<a name="l02169"></a>02169  
<a name="l02170"></a>02170   prDir,  
<a name="l02171"></a>02171   prFile, 
<a name="l02172"></a><a class="code" href="classCZipArchive.html#567d568ba3e724cd41d15db4e7aa724f36adfe21a31a4f045b9ebfe265e2f017">02172</a>   prAuto  
<a name="l02173"></a>02173  };
<a name="l02174"></a>02174 
<a name="l02189"></a>02189  CZipString PredictFileNameInZip(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath, <span class="keywordtype">int</span> iWhat = prAuto)<span class="keyword">const </span>;
<a name="l02190"></a>02190 
<a name="l02223"></a>02223  ZIP_U32_U64 PredictMaximumFileSizeInArchive(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>&amp; fh) <span class="keyword">const</span>;
<a name="l02224"></a>02224 
<a name="l02242"></a>02242  ZIP_U32_U64 PredictMaximumFileSizeInArchive(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath) <span class="keyword">const</span>;
<a name="l02243"></a>02243  
<a name="l02244"></a>02244 
<a name="l02265"></a>02265  ZIP_U16_U64 WillBeDuplicated(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath, <span class="keywordtype">bool</span> bFileNameOnly = <span class="keyword">false</span>, <span class="keywordtype">int</span> iWhat = prAuto);
<a name="l02266"></a>02266 
<a name="l02285"></a>02285  CZipString PredictExtractedFileName(LPCTSTR lpszFileNameInZip, LPCTSTR lpszPath, <span class="keywordtype">bool</span> bFullPath, LPCTSTR lpszNewName = NULL)<span class="keyword">const </span>;
<a name="l02286"></a>02286 
<a name="l02287"></a>02287 
<a name="l02297"></a>02297  CZipString TrimRootPath(<a class="code" href="classCZipPathComponent.html">CZipPathComponent</a>&amp; zpc) <span class="keyword">const </span>;
<a name="l02298"></a>02298 
<a name="l02315"></a>02315  <span class="keyword">static</span> <span class="keywordtype">bool</span> RemovePathBeginning(LPCTSTR lpszBeginning, CZipString&amp; szPath, ZIPSTRINGCOMPARE pCompareFunction);
<a name="l02316"></a>02316 
<a name="l02338"></a><a class="code" href="classCZipArchive.html#ec981beb4dfb55e4a2f054c410ee3031">02338</a>  <span class="keywordtype">void</span> SetCaseSensitivity(<span class="keywordtype">bool</span> bCaseSensitive) 
<a name="l02339"></a>02339  {
<a name="l02340"></a>02340   m_bCaseSensitive = bCaseSensitive;
<a name="l02341"></a>02341   m_pZipCompare = GetCZipStrCompFunc(bCaseSensitive);
<a name="l02342"></a>02342  }
<a name="l02343"></a>02343 
<a name="l02352"></a>02352  <span class="keywordtype">void</span> GetCentralDirInfo(<a class="code" href="structCZipCentralDir_1_1Info.html">CZipCentralDir::Info</a>&amp; info)<span class="keyword">const</span>;
<a name="l02353"></a>02353  
<a name="l02354"></a>02354 
<a name="l02367"></a><a class="code" href="classCZipArchive.html#3c8dd12deab7ecd02d8a760fd9709259">02367</a>  ZIP_U32_U64 GetCentralDirSize(<span class="keywordtype">bool</span> bWhole = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l02368"></a>02368 <span class="keyword"> </span>{
<a name="l02369"></a>02369   <span class="keywordflow">return</span> m_centralDir.GetSize(bWhole);
<a name="l02370"></a>02370  }
<a name="l02371"></a>02371 
<a name="l02380"></a><a class="code" href="classCZipArchive.html#c50bc9678b14ae075d2c252f0b38bd0d">02380</a>  <span class="keywordtype">bool</span> IsReadOnly(){<span class="keywordflow">return</span> m_storage.IsReadOnly();}
<a name="l02381"></a>02381 
<a name="l02394"></a><a class="code" href="classCZipArchive.html#af36a98067f98b36be9ee39cca78322d">02394</a>  <span class="keywordtype">void</span> SetBytesBeforeZip(ZIP_U32_U64 uCount = 0)
<a name="l02395"></a>02395  {
<a name="l02396"></a>02396   <span class="keywordflow">if</span> (!IsClosed())
<a name="l02397"></a>02397   {
<a name="l02398"></a>02398    ZIPTRACE(<span class="stringliteral">"%s(%i) : Set it before opening the archive.\n"</span>);
<a name="l02399"></a>02399    <span class="keywordflow">return</span>;
<a name="l02400"></a>02400   }
<a name="l02401"></a>02401   m_storage.m_uBytesBeforeZip = uCount;
<a name="l02402"></a>02402  }
<a name="l02403"></a>02403 
<a name="l02413"></a><a class="code" href="classCZipArchive.html#95cdda5fd6e8fb1f9b02f305746413ad">02413</a>  ZIP_U32_U64 GetBytesBeforeZip()
<a name="l02414"></a>02414  {
<a name="l02415"></a>02415   <span class="keywordflow">return</span> m_storage.m_uBytesBeforeZip;
<a name="l02416"></a>02416  }
<a name="l02417"></a>02417 
<a name="l02426"></a><a class="code" href="classCZipArchive.html#dfa8fac6a0fed81431908febedadd13c">02426</a>  <span class="keywordtype">void</span> SetIgnoreCRC(<span class="keywordtype">bool</span> bIgnore = <span class="keyword">true</span>){m_bIgnoreCRC = bIgnore;}
<a name="l02427"></a>02427 
<a name="l02436"></a><a class="code" href="classCZipArchive_1_1CWildcard.html">02436</a>  <span class="keyword">class </span>ZIP_API CWildcard  
<a name="l02437"></a>02437  {
<a name="l02438"></a>02438  <span class="keyword">public</span>:
<a name="l02439"></a>02439   
<a name="l02440"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#83082993cb32d3e50311a840b68f741d">02440</a>   <span class="keyword">enum</span> <a class="code" href="classCZipArchive_1_1CWildcard.html#83082993cb32d3e50311a840b68f741d">Match</a>
<a name="l02441"></a>02441   {
<a name="l02442"></a>02442    matchNone,   
<a name="l02443"></a>02443    matchValid,   
<a name="l02444"></a>02444    matchEnd,   
<a name="l02445"></a>02445    matchAbort,   
<a name="l02446"></a>02446    matchRange,   
<a name="l02447"></a>02447    matchLiteral,  
<a name="l02448"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#83082993cb32d3e50311a840b68f741dcef3c83579ae0549a5c1ca5da35be0c0">02448</a>    matchPattern  
<a name="l02449"></a>02449   };
<a name="l02450"></a>02450   
<a name="l02451"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#f991dcdcb6328f1016e307b795f63fe9">02451</a>   <span class="keyword">enum</span> <a class="code" href="classCZipArchive_1_1CWildcard.html#f991dcdcb6328f1016e307b795f63fe9">Pattern</a> 
<a name="l02452"></a>02452   {
<a name="l02453"></a>02453    patternEmpty = -4, 
<a name="l02454"></a>02454    patternClose,  
<a name="l02455"></a>02455    patternRange,  
<a name="l02456"></a>02456    patternEsc,   
<a name="l02457"></a>02457    patternValid,  
<a name="l02458"></a>02458   };
<a name="l02459"></a>02459   
<a name="l02460"></a>02460   
<a name="l02478"></a>02478   <span class="keywordtype">bool</span> IsMatch(LPCTSTR lpszText, <span class="keywordtype">int</span>* iRetCode = NULL);
<a name="l02479"></a>02479 
<a name="l02490"></a>02490   <span class="keyword">static</span> <span class="keywordtype">bool</span> IsPattern(LPCTSTR lpszPattern);
<a name="l02491"></a>02491 
<a name="l02505"></a>02505   <span class="keyword">static</span> <span class="keywordtype">bool</span> IsPatternValid(LPCTSTR lpszPattern, <span class="keywordtype">int</span>* iErrorType = NULL);
<a name="l02506"></a>02506   
<a name="l02524"></a>02524   <span class="keyword">static</span> <span class="keywordtype">int</span> Match(LPCTSTR lpszPattern, LPCTSTR lpszText);
<a name="l02525"></a>02525   
<a name="l02529"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#460d60f6ece652bf403092e8571fd91f">02529</a>   CWildcard(){}
<a name="l02530"></a>02530 
<a name="l02543"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#d484e85976fa3df6f16b4b9188045c9b">02543</a>   CWildcard(LPCTSTR lpszPattern, <span class="keywordtype">bool</span> bCaseSensitive)
<a name="l02544"></a>02544   {
<a name="l02545"></a>02545    SetPattern(lpszPattern, bCaseSensitive);
<a name="l02546"></a>02546   }
<a name="l02547"></a>02547 
<a name="l02548"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#1d954b4ab0ff86711d40a80ad727fac5">02548</a>   <span class="keyword">virtual</span> ~CWildcard(){}
<a name="l02549"></a>02549   
<a name="l02562"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#fff29aae770b26e602d6fcbc177e8654">02562</a>   <span class="keywordtype">void</span> SetPattern(LPCTSTR lpszPattern, <span class="keywordtype">bool</span> bCaseSensitive)
<a name="l02563"></a>02563   {
<a name="l02564"></a>02564    m_szPattern = lpszPattern;
<a name="l02565"></a>02565    m_bCaseSensitive=bCaseSensitive;
<a name="l02566"></a>02566    <span class="keywordflow">if</span> (!bCaseSensitive)
<a name="l02567"></a>02567     m_szPattern.MakeLower();
<a name="l02568"></a>02568   }
<a name="l02569"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#0a0d0ebe89e6cca0cc7f109b618d27bc">02569</a>   operator LPCTSTR()
<a name="l02570"></a>02570   {
<a name="l02571"></a>02571    <span class="keywordflow">return</span> (LPCTSTR)m_szPattern;
<a name="l02572"></a>02572   }
<a name="l02573"></a>02573  <span class="keyword">protected</span>:
<a name="l02574"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#5bb4588838d63c1e01779563cf778e6f">02574</a>   <span class="keywordtype">bool</span> m_bCaseSensitive;  
<a name="l02575"></a>02575   <span class="keyword">static</span> <span class="keywordtype">int</span> MatchAfterStar(LPCTSTR p , LPCTSTR t);
<a name="l02576"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#5e67798d89726053202b119f14257f72">02576</a>   CZipString m_szPattern;
<a name="l02577"></a>02577  };
<a name="l02578"></a>02578 
<a name="l02579"></a>02579 
<a name="l02606"></a>02606  <span class="keywordtype">void</span> FindMatches(LPCTSTR lpszPattern, CZipIndexesArray&amp; ar, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>);
<a name="l02607"></a>02607 
<a name="l02608"></a>02608 
<a name="l02626"></a>02626  <span class="keywordtype">bool</span> <a class="code" href="namespaceZipPlatform.html#7186bd71ba97c2d20c8f24b0b7b07f0a">RenameFile</a>(ZIP_U16_U64 uIndex, LPCTSTR lpszNewName);
<a name="l02627"></a>02627  
<a name="l02638"></a><a class="code" href="classCZipArchive.html#467a1645b33dc3af31c9786dad37730f">02638</a>  <span class="keywordtype">bool</span> RemoveCentralDirectoryFromDisk()
<a name="l02639"></a>02639  {
<a name="l02640"></a>02640   <span class="keywordflow">if</span> (IsClosed())
<a name="l02641"></a>02641   {
<a name="l02642"></a>02642    ZIPTRACE(<span class="stringliteral">"%s(%i) : ZipArchive is closed.\n"</span>);
<a name="l02643"></a>02643    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02644"></a>02644   }
<a name="l02645"></a>02645  
<a name="l02646"></a>02646   <span class="keywordflow">if</span> (m_storage.IsSegmented())
<a name="l02647"></a>02647   {
<a name="l02648"></a>02648    ZIPTRACE(<span class="stringliteral">"%s(%i) : You cannot remove the central directory from a segmented archive.\n"</span>);
<a name="l02649"></a>02649    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02650"></a>02650   }
<a name="l02651"></a>02651   m_centralDir.RemoveFromDisk();
<a name="l02652"></a>02652   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02653"></a>02653  }
<a name="l02654"></a>02654 
<a name="l02661"></a><a class="code" href="classCZipArchive.html#940810c83896365f88e4be14809674c9">02661</a>  <span class="keywordtype">bool</span> m_bRemoveDriveLetter;
<a name="l02662"></a>02662 
<a name="l02663"></a>02663 <span class="keyword">protected</span>:
<a name="l02664"></a>02664 
<a name="l02676"></a>02676  <span class="keywordtype">bool</span> OpenNewFile(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a> &amp; header, <span class="keywordtype">int</span> iLevel, LPCTSTR lpszFilePath, ZIP_U16_U64 uReplaceIndex);
<a name="l02677"></a>02677 
<a name="l02682"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html">02682</a>  <span class="keyword">struct </span>ZIP_API CZipSmClrPass
<a name="l02683"></a>02683  {
<a name="l02684"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html#ee1b71b64ac2cc59098747b2ee03ce28">02684</a>   <span class="keywordtype">void</span> ClearPasswordSmartly(CZipArchive* pZip)
<a name="l02685"></a>02685   {
<a name="l02686"></a>02686    m_pZip = pZip;
<a name="l02687"></a>02687    m_szPass = pZip-&gt;<a class="code" href="classCZipArchive.html#1ae3937a27e2bcae5993ea6eb5d2f22c">GetPassword</a>();
<a name="l02688"></a>02688    <span class="keywordflow">if</span> (!m_szPass.IsEmpty())
<a name="l02689"></a>02689     pZip-&gt;<a class="code" href="classCZipArchive.html#bbe0d1ba17c664a8c9c15bfecb37a274">SetPassword</a>();
<a name="l02690"></a>02690   }
<a name="l02691"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html#57d7d6a6e041cf37cc246cc76a155476">02691</a>   ~CZipSmClrPass()
<a name="l02692"></a>02692   {
<a name="l02693"></a>02693    <span class="keywordflow">if</span> (!m_szPass.IsEmpty())
<a name="l02694"></a>02694     m_pZip-&gt;SetPassword(m_szPass);
<a name="l02695"></a>02695   }
<a name="l02696"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html#c28199438528b2d18cb0d18e9d2d21fc">02696</a>   CZipString m_szPass;
<a name="l02697"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html#4a27d8ecc5f1f1072d6ecd1d6cf672cc">02697</a>   CZipArchive* m_pZip;
<a name="l02698"></a>02698  };
<a name="l02699"></a>02699  
<a name="l02705"></a><a class="code" href="structCZipArchive_1_1CZipClbckStrg.html">02705</a>  <span class="keyword">struct </span>ZIP_API CZipClbckStrg : <span class="keyword">public</span> CZipMap&lt;CallbackType, CZipActionCallback*&gt;  
<a name="l02706"></a>02706  {
<a name="l02707"></a><a class="code" href="structCZipArchive_1_1CZipClbckStrg.html#c7a26aa5fc637ed2d37f79508d0ef2a8">02707</a>   <span class="keywordtype">void</span> Set(<a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback, <a class="code" href="classCZipArchive.html#07cdf46e463d58a346e8446f7e7b8730">CallbackType</a> iType)
<a name="l02708"></a>02708   {
<a name="l02709"></a>02709    <span class="keywordflow">if</span> (pCallback)
<a name="l02710"></a>02710    {
<a name="l02711"></a>02711     SetAt(iType, pCallback);
<a name="l02712"></a>02712    }
<a name="l02713"></a>02713    <span class="keywordflow">else</span>
<a name="l02714"></a>02714     RemoveKey(iType);
<a name="l02715"></a>02715   }
<a name="l02716"></a><a class="code" href="structCZipArchive_1_1CZipClbckStrg.html#c5e75c80fb494029cedad09527aafb3f">02716</a>   <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* Get(<a class="code" href="classCZipArchive.html#07cdf46e463d58a346e8446f7e7b8730">CallbackType</a> iType)
<a name="l02717"></a>02717   {
<a name="l02718"></a>02718    <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback = NULL;
<a name="l02719"></a>02719    <span class="keywordflow">if</span> (Lookup(iType, pCallback))
<a name="l02720"></a>02720    {
<a name="l02721"></a>02721     pCallback-&gt;<a class="code" href="structCZipActionCallback.html#bc0a90bcffefb9629ffa9c8421173338">m_iType</a> = iType;
<a name="l02722"></a>02722     <span class="keywordflow">return</span> pCallback;
<a name="l02723"></a>02723    }
<a name="l02724"></a>02724    <span class="keywordflow">else</span>
<a name="l02725"></a>02725     <span class="keywordflow">return</span> NULL;
<a name="l02726"></a>02726   }
<a name="l02727"></a>02727  
<a name="l02728"></a>02728  };
<a name="l02729"></a>02729  
<a name="l02730"></a>02730  
<a name="l02734"></a><a class="code" href="classCZipArchive.html#8ee00d832303a28ada2540baf1a5006d">02734</a>  CZipClbckStrg m_callbacks;
<a name="l02735"></a>02735  
<a name="l02736"></a>02736 
<a name="l02740"></a>02740  <span class="keywordtype">void</span> WriteCentralDirectory(<span class="keywordtype">bool</span> bFlush = <span class="keyword">true</span>);
<a name="l02741"></a>02741 
<a name="l02745"></a><a class="code" href="classCZipArchive.html#63c15f0ac2da695bbf5b2abaaa1c63b9">02745</a>  <span class="keywordtype">bool</span> m_bCaseSensitive;
<a name="l02746"></a>02746 
<a name="l02751"></a><a class="code" href="classCZipArchive.html#583ac1a566a2d990a633ed667da1c143">02751</a>  ZIPSTRINGCOMPARE m_pZipCompare;
<a name="l02752"></a>02752 
<a name="l02758"></a><a class="code" href="classCZipArchive.html#ca3522ae4871ebcce85021a22455821c">02758</a>  CZipInternalInfo m_info;
<a name="l02759"></a>02759 
<a name="l02760"></a>02760  
<a name="l02766"></a><a class="code" href="classCZipArchive.html#54baf3557f580c2db1577a3c3da98a2b">02766</a>  <a class="code" href="classCZipStorage.html">CZipStorage</a> m_storage;
<a name="l02767"></a>02767 
<a name="l02773"></a><a class="code" href="classCZipArchive.html#ee3ada39e4ec242778b433cfd887278e">02773</a>  <a class="code" href="classCZipCentralDir.html">CZipCentralDir</a> m_centralDir;
<a name="l02774"></a>02774 
<a name="l02778"></a><a class="code" href="classCZipArchive.html#50a0edbfe33ae586c7a119c93b326671">02778</a>  <span class="keyword">enum</span> <a class="code" href="classCZipArchive.html#50a0edbfe33ae586c7a119c93b326671">OpenFileType</a>
<a name="l02779"></a>02779  {
<a name="l02780"></a>02780   extract = -1, 
<a name="l02781"></a>02781   nothing,  
<a name="l02782"></a><a class="code" href="classCZipArchive.html#50a0edbfe33ae586c7a119c93b32667199445f88722247f1f8cbb185572a3542">02782</a>   compress  
<a name="l02783"></a>02783  };
<a name="l02784"></a>02784  
<a name="l02788"></a><a class="code" href="classCZipArchive.html#cc19748471fff7809c8020ebe3c295df">02788</a>  <span class="keywordtype">char</span> m_iFileOpened;
<a name="l02789"></a>02789 
<a name="l02793"></a><a class="code" href="classCZipArchive.html#41687a9571643752cacfe5acc90ccff9">02793</a>  <span class="keywordtype">bool</span> m_bAutoFlush;
<a name="l02794"></a>02794 
<a name="l02798"></a><a class="code" href="classCZipArchive.html#bcd2afd5681aa16e077ec922ac507173">02798</a>  <span class="keywordtype">bool</span> m_bIgnoreCRC;
<a name="l02799"></a>02799 
<a name="l02803"></a><a class="code" href="classCZipArchive.html#a1895d5447111f55159aed88fa1f1d4d">02803</a>  CZipString m_szRootPath;
<a name="l02804"></a>02804 
<a name="l02808"></a><a class="code" href="classCZipArchive.html#0fe6e4697b6a9e7e6f52011c66621936">02808</a>  CZipString m_szTempPath;
<a name="l02809"></a>02809 
<a name="l02810"></a>02810 
<a name="l02819"></a>02819  <span class="keywordtype">void</span> OpenInternal(<span class="keywordtype">int</span> iMode);
<a name="l02820"></a>02820 
<a name="l02824"></a><a class="code" href="classCZipArchive.html#23a52208759f43b1efe57af59264a407">02824</a>  <span class="keywordtype">int</span> m_iArchiveSystCompatib;
<a name="l02825"></a>02825 
<a name="l02829"></a><a class="code" href="classCZipArchive.html#b2527e478136e550334b99eb7605605e">02829</a>  <span class="keywordtype">bool</span> m_bDetectZlibMemoryLeaks;
<a name="l02830"></a>02830 
<a name="l02834"></a><a class="code" href="classCZipArchive.html#fd1df17f464a949ea40859bae5689e4a">02834</a>  <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> m_pszPassword;
<a name="l02835"></a>02835 
<a name="l02840"></a>02840  <span class="keywordtype">void</span> EmptyPtrList();
<a name="l02841"></a>02841 
<a name="l02847"></a>02847  <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* CurrentFile();
<a name="l02848"></a>02848 
<a name="l02852"></a><a class="code" href="classCZipArchive.html#e8d24271cb186f4db02064d82c9f6655">02852</a>  <span class="keywordtype">void</span> ClearCryptograph()
<a name="l02853"></a>02853  {
<a name="l02854"></a>02854   <span class="keywordflow">if</span> (m_pCryptograph)
<a name="l02855"></a>02855   {
<a name="l02856"></a>02856    <span class="keyword">delete</span> m_pCryptograph;
<a name="l02857"></a>02857    m_pCryptograph = NULL;
<a name="l02858"></a>02858   }
<a name="l02859"></a>02859  }
<a name="l02860"></a>02860 
<a name="l02866"></a><a class="code" href="classCZipArchive.html#008c35d0a4f148b88c5d2177ebab46ec">02866</a>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> CreateCryptograph(<span class="keywordtype">int</span> iEncryptionMethod)
<a name="l02867"></a>02867  {
<a name="l02868"></a>02868   ClearCryptograph();
<a name="l02869"></a>02869   m_pCryptograph = <a class="code" href="classCZipCryptograph.html#67ea47605ae88bc06e0a07837505459e">CZipCryptograph::CreateCryptograph</a>(iEncryptionMethod);
<a name="l02870"></a>02870  }
<a name="l02871"></a>02871 
<a name="l02875"></a><a class="code" href="classCZipArchive.html#8650f1fa6f5eb19665d451921b27abca">02875</a>  <a class="code" href="classCZipCryptograph.html">CZipCryptograph</a>* m_pCryptograph;
<a name="l02876"></a>02876 
<a name="l02880"></a><a class="code" href="classCZipArchive.html#4982e7da972267e0cd5db1e5b41094eb">02880</a>  <span class="keywordtype">int</span> m_iEncryptionMethod;
<a name="l02881"></a>02881 
<a name="l02882"></a>02882 
<a name="l02883"></a>02883 <span class="keyword">private</span>:
<a name="l02884"></a>02884 
<a name="l02885"></a>02885  <span class="keyword">struct </span>ZIP_API CZipDeleteInfo
<a name="l02886"></a>02886  {
<a name="l02887"></a>02887   CZipDeleteInfo(){m_pHeader = NULL; m_bDelete = <span class="keyword">false</span>;}
<a name="l02888"></a>02888   CZipDeleteInfo(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* pHeader, <span class="keywordtype">bool</span> bDelete)
<a name="l02889"></a>02889    :m_pHeader(pHeader), m_bDelete (bDelete){}
<a name="l02890"></a>02890   <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* m_pHeader;
<a name="l02891"></a>02891   <span class="comment">//bool operator &lt; (const CZipDeleteInfo&amp; di) const</span>
<a name="l02892"></a>02892   <span class="comment">//{</span>
<a name="l02893"></a>02893   <span class="comment">// return m_pHeader-&gt;m_uOffset &lt; di.m_pHeader-&gt;m_uOffset;</span>
<a name="l02894"></a>02894   <span class="comment">//}</span>
<a name="l02895"></a>02895   <span class="comment">//bool operator &gt; (const CZipDeleteInfo&amp; di) const</span>
<a name="l02896"></a>02896   <span class="comment">//{</span>
<a name="l02897"></a>02897   <span class="comment">// return m_pHeader-&gt;m_uOffset &gt; di.m_pHeader-&gt;m_uOffset;</span>
<a name="l02898"></a>02898   <span class="comment">//}</span>
<a name="l02899"></a>02899   <span class="comment">//bool operator == (const CZipDeleteInfo&amp; di) const</span>
<a name="l02900"></a>02900   <span class="comment">//{</span>
<a name="l02901"></a>02901   <span class="comment">// return m_pHeader-&gt;m_uOffset == di.m_pHeader-&gt;m_uOffset;</span>
<a name="l02902"></a>02902   <span class="comment">//}</span>
<a name="l02903"></a>02903   <span class="comment">//bool operator &lt;= (const CZipDeleteInfo&amp; di) const</span>
<a name="l02904"></a>02904   <span class="comment">//{</span>
<a name="l02905"></a>02905   <span class="comment">// return m_pHeader-&gt;m_uOffset &lt;= di.m_pHeader-&gt;m_uOffset;</span>
<a name="l02906"></a>02906   <span class="comment">//}</span>
<a name="l02907"></a>02907   <span class="comment">//bool operator &gt;= (const CZipDeleteInfo&amp; di) const</span>
<a name="l02908"></a>02908   <span class="comment">//{</span>
<a name="l02909"></a>02909   <span class="comment">// return m_pHeader-&gt;m_uOffset &gt;= di.m_pHeader-&gt;m_uOffset;</span>
<a name="l02910"></a>02910   <span class="comment">//}</span>
<a name="l02911"></a>02911   <span class="keywordtype">bool</span> m_bDelete;
<a name="l02912"></a>02912  };
<a name="l02913"></a>02913 
<a name="l02914"></a>02914  <span class="keywordtype">void</span> MakeSpaceForReplace(ZIP_U16_U64 iReplaceIndex, ZIP_U32_U64 uTotal, LPCTSTR lpszFileName);
<a name="l02915"></a>02915 
<a name="l02916"></a>02916  <span class="keywordtype">void</span> MovePackedFiles(ZIP_U32_U64 uStartOffset, ZIP_U32_U64 uEndOffset, ZIP_U32_U64 uMoveBy, <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback, <span class="keywordtype">bool</span> bForward = <span class="keyword">false</span>);
<a name="l02917"></a>02917  
<a name="l02918"></a>02918  <span class="keywordtype">bool</span> RemoveLast(<span class="keywordtype">bool</span> bRemoveAnyway = <span class="keyword">false</span>);
<a name="l02919"></a>02919 
<a name="l02920"></a>02920  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, ZIP_U16_U64 uIndex, LPCTSTR lpszNewFileName, ZIP_U16_U64 iReplaceIndex, <span class="keywordtype">bool</span> bKeepSystComp, <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback);
<a name="l02921"></a>02921 
<a name="l02922"></a>02922  <span class="keywordtype">bool</span> UpdateReplaceIndex(ZIP_U16_U64&amp; iReplaceIndex);
<a name="l02923"></a>02923  
<a name="l02924"></a>02924  <span class="keywordtype">void</span> CheckForError(<span class="keywordtype">int</span> iErr);
<a name="l02925"></a>02925 
<a name="l02926"></a>02926  <span class="keywordtype">void</span> ThrowError(<span class="keywordtype">int</span> err, <span class="keywordtype">bool</span> bZlib = <span class="keyword">false</span>);
<a name="l02927"></a>02927 
<a name="l02928"></a>02928  <span class="keyword">typedef</span> CZipPtrList&lt;void*&gt;::iterator CZipPtrListIter;
<a name="l02929"></a>02929  CZipPtrList&lt;void*&gt; m_list; 
<a name="l02930"></a>02930 
<a name="l02931"></a>02931  <span class="keyword">static</span> <span class="keywordtype">void</span>* _zliballoc(<span class="keywordtype">void</span>* opaque, UINT items, UINT size); 
<a name="l02932"></a>02932  <span class="keyword">static</span> <span class="keywordtype">void</span> _zlibfree(<span class="keywordtype">void</span>* opaque, <span class="keywordtype">void</span>* address); 
<a name="l02933"></a>02933 
<a name="l02934"></a>02934  <span class="keyword">static</span> <span class="keyword">const</span> TCHAR m_gszCopyright[];  
<a name="l02935"></a>02935 };
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="preprocessor">#if (_MSC_VER &gt; 1000) &amp;&amp; (defined ZIP_HAS_DLL)</span>
<a name="l02938"></a>02938 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning (pop)</span>
<a name="l02939"></a>02939 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02940"></a>02940 <span class="preprocessor"></span>
<a name="l02941"></a>02941 <span class="preprocessor">#endif // !defined(ZIPARCHIVE_ZIPARCHIVE_DOT_H)</span>
</pre></div><hr><address><small>
The ZipArchive Library Copyright &copy;&nbsp;2000 - 2006 Tadeusz Dracz. Generated at Mon Nov 27 21:42:23 2006.
</small></address>
</body>
</html>
